---
layout: post
title:  "嵌入式Linux考试没有重点"
imges: 
date:   2019-12-20 10:00:00 +0800
description: 赶紧背一波
tags: 嵌入式linux
---




第一章：安装开发环境=>这里有10分的题目
建议：优先看学习通题目和6次实验内容！！ok猜的
共享内存，消息队列，多线程、socket通信，四个是重点
记住关键函数，分析输出结果。 无需死记硬背，都是填空补充代码。

### 出题方式--猜测
    安装开发环境 => 10分
    选择题15*2 => 30分（上面的10分可能在这里面）
    填空题10*2 => 20分 （学习通记得看）
    判断题10*1 => 10分 （依然是学习通）
    分析题4*5  => 20分
    应用题4*5  => 20分
    其中分析题和应用题考点分布：
        共享内存，
        消息队列，
        多线程、
        socket通信
    书上的源代码还有运行结果慢慢看！根据运行结果分析关键函数，千万不能背代码！


## 选择题一：
### 1. open函数打开的文件描述符fd要定位到文件尾的最后10个字符处,下列哪个代码正确。(D)

A. Iseek(fd, 10, SEEK SET)  
B. Iseek(fd, 10, SEEK END)  
C. Iseek(fd, 10, SEEK CUR)  
**D. Iseek(fd, -10, SEEK END)**  

### 2. 串口设备文件,用于其设置的结构体中,哪个是用于设置read函数的调用方式的(C)

A、c_lflag  
B、c_line  
**C、c_cc[NCC]**  
D、c_cflag  

### 3用fopen函数打开一个文件，用于把数据写在文件尾部，打开模式字符串为（ C    ）。

A、r+b  
B、wb  
**C、ab**  
D、rb  

### 4从标准控制台输入设备读取一个字符函数为（       B      ）。

A、fputc  
**B、fgetc**  
C、fputs  
D、fgets  

## 填空题一：
1. lockf函数对文件上的锁，是( **建议性**  )锁。

2. fcntl函数给文件上的读取锁，也称为( **共享**  )锁。

3. 常用格式化输出函数有( **vsprintf** )和( **sprintf**  )。

## 判断题一：
1. 代码 open( "/home/myfile",O_WRONLY | O_WRWR); 是否正确？  
**我的答案：×**

2. 用open函数打开的文件描述符，需用fclose函数关闭  
**我的答案：×**

3. 可以对文件的不同部分，分别建立读取锁和写入锁。  
**我的答案：√**

4. poll函数不能监听文件是否可写入的事件。   
**我的答案：×** 

5. 用fopen函数打开的可写文件，可用write函数写入数据。   
**我的答案：×**

## Linux多任务编程 
## 选择题二：
### 1. 进程结束前，需要清理IO缓冲，必须使用哪个函数（ B  ）。

A、_exit()  
**B、exit()**  
C、return  

### 2. 父进程等待子进程结束或接收到指定信号，非阻塞版本的函数是（ B       ）。

A、wait()  
**B、waitpid()**

### 3. 改变进程工作目录的函数是（    B   ）。

A、umusk  
**B、chdir**  
C、syslogopen  
D、fork  

## 填空题二：
1. 新进程要摆脱原进程和进程组的控制，需要调用( **setsid**  )函数。【只填函数名，无需参数】

2. 新建进程要成为守护进程，除了建立新的会话、改变当前目录，、重设文件权限掩码，还需要关闭从父进程继承下来的( **文件描述符**  )。

## 判断题二：
1. Linux中创建新进程的唯一方法是使用fork()函数。  
**我的答案：√** 

2. exec系列函数，用于在进程中启动一个程序。在执行之后，原调用进程的内容，除了PID，其它全部被新进程替换了。  
**我的答案：√** 

3. 僵尸进程会占用系统的内存资源，但不会占用进程号资源。  
**我的答案：×** 

4. 父进程使用wait或waitpid函数，可有效消除僵尸进程。  
**我的答案：√** 

5. 父进程忽略系统的SIGCHLD信号，也可避免产生僵尸进程。  
**我的答案：√**

## Linux进程间通信
## 选择题三：
### 1. 检查有名管道是否存在的函数是（         B       ）。

A、popen  
**B、access**    
C、fgets  
D、singnal  

### 2. 让进程暂停执行，可使用函数（       B          ）。

A、sleep  
**B、pause**

### 3. 进程要处理信号集，使用哪个函数（      B        ）。

A、signal  
**B、sigaction**    


### 4. 信号量的P操作是（  C    ）一个资源。

A、选择   
B、释放    
**C、占用**  
D、销毁    

### 5.创建共享内存的函数是（   B         ）。

A、shmat   
**B、shmget**  
C、shmdt  
D、shmctl    

## 填空题三：
1. 管道是基于(&emsp; **文件描述符**  &emsp;)的通信方式。创见无名管道的函数名是(&emsp; **pipe()**   &emsp;)。  

2. 创建有名管道的函数是（&emsp;     **mkfifo()**      &emsp;）。

3. 创建消息队列的函数是(&emsp; **msgget()**  &emsp;)  
   往消息队列添加消息的函数是(&emsp; **msgsnd()**  &emsp;)  
   从消息队列读取消息的函数是 <u> msgrcv() </u>  
## 判断题三：
1. Linux进程，只允许有一个闹钟时间，它会向进程发送SIGALRM信号。  
**我的答案：√**   

2. 信号量的P操作，是原子操作，如果没有资源可用，将阻塞进程。  
**我的答案：√**

---
## 考试内容绝大部分在学习通作业、教学案例、实验程序中、记函数名称，用法，分析实验结果。
# 对于书上的尽力而为叭,代码我就不粘贴了，主要是一些函数，能见名知意即可！

##### 基本文件操作
[！！可以先看看什么是文件描述符](http://c.biancheng.net/view/3066.html)

---

### 1. open() 、 close() 、read()、 write()  
函数详解:  

    1. int open(const char *pathname, int flag, int perms)    
    1）参数pathname:被打开的文件名可包含其路径   
    2）参数flag: 文件的打开方式（只写了3种）  
    O_RDONLY:只读方式打开文件  
    O_WRONLY:只写方式打开文件  
    O_RDWR:读写方式打开文件   
    3）参数 perms:  被打开文件的存取权限   
    可以使用宏定义S_I(R/W/X)(USR/GRP/OTH)
    R W X ：分别表示读写可执行权限   
    USR GRP OTH:分别表示文件所有者、文件所属组、其他用户  
    
    2. int close(int fd)  
    1）参数fd: 文件描述符  
    返回值：成功为0 、失败为-1

    3. ssize_t read(inf fd , void *buf , size_t count)  
    1）参数fd: 文件描述符   
    2）参数buf: 指定存储器读出数据的缓冲区  
    3）count: 指定读出的字节数  
    返回值：成功：读到的字节数   
            0：已到达文件尾   
            -1：出错  

    4. ssize_t write(inf fd , void *buf , size_t count)
    1）参数fd: 文件描述符   
    2）参数buf: 指定存储器写入数据的缓冲区  
    3）count: 指定读出的字节数  
    返回值：  
    成功：已写的字节数     
    -1：出错

    4. off_t lseek(int fd , off_t offset , int whenc__
    1）fd:文件描述符
    2）offset:偏移量，每次读写操作所需要移动端距离，单位是 __字节__
    3) whence:当前位置的基点
    返回值：  
    成功：文件的当前位移  
    -1：出错    

    #### 对应实例查看copy_file.c

---

### 2. 文件锁，涉及到两个函数fcntl()和lockf()  
    lockf()用于对文件施加建议性锁 ，这里不展开讲解 
    fcntl()可添加建议性锁、强制性锁、包括对文件的某一记录上锁，即记录锁。  

    1) int fcntl(int fd , int cmd , struct flock *lock)  
    参数fd:文件描述符  
    cmd:这个参数很多取值，具体看书47页  
    lock:设置记录锁的具体状态

    返回值：
        成功：0
        出错：-1
    
    #### 对应实例查看lock_set.c
    
### 3. 给文件上读取锁，写入锁 ，解锁

lock_set(fd,F_WRLCK)=>上写入锁，一个文件上了写入锁，另一个程序想再给这个文件上写入锁就不行了，就像是上厕所，一个坑只能同时蹲一个人，

lock_set(fd , F_RDLCK)=>上读取锁，一个文件上了读取锁，另一个终端程序也能同时对这个文件上读取锁，就像是看小说，大家一起看

lock_set(fd , F_UNLCK)=>给文件解锁

select()函数   
这里就提几个常用的  
FD_ZERO(fd_set *set)=>清除一个文件描述符集  
FD_SET(int fd , fd_set *set) => 将一个文件描述符加入文件描述符集中  
FD_ClR(int fd , fd_set *set) => 将一个文件描述符从文件描述符集中清除  
FD_ISSET(int fd , fd_set *set) => 判断一个文件描述符是否在文件描述符集中

## 进程控制编程  
fork()用于创建子进程  
根据返回值判断是子进程还是父进程  
返回值：  
    0：子进程  
    大于0：父进程  
    -1：表示出错  

####对应代码：fork.c

exec函数族：exec函数族提供了在一个进程中启动另一个程序执行的方法  
主要看代码个运行结果  

exit()和_exit()
相同点：都能终止程序进行  
区别：  exit()函数在终止当前进程之前要检查该进程打开过哪些文件，八文件缓冲区中的内容写回文件。  

wait()和waitpid()
wait()函数使父进程（也就是调用wait()的进程）阻塞，直到一个子进程结束或该进程收到指定的信号为止。  

pid_t wait(int *status)   
参数：是一个整数，是子进程退出时的状态
返回值：
    成功：已结束运行的子进程的进程号
    失败：-1

pid_t waitpid(pid_t pid , int *status , int options)  
参数:pid  

    pid>0,指定的子进程只要还不结束，不管其他子进程是否结束，waitpid()也会一直等待下去  

    pid=-1:等待任何一个子进程退出 => 功能相当于wait()

    其他取值就不管了
    
参数status:是一个整数，是子进程退出时的状态  

参数options: **为0的时候，阻塞父进程，等待子进程的退出** 

### Linux守护进程 
查看daemon.c  
### 僵尸进程
代码查看zomble.c   
避免僵尸进程的函数signal()  
相关代码看 avoid_zomble.c  

### 编写守护进程 
相关代码查看daemon_proc.c 

## 管道！！！
    主要还是介绍无名管道和有名管道  
    最好看书上134页对于管道的介绍！！！！    
    无名管道创建：pipe(),pipe()函数创建的管道两端处于同一个进程中，所以没啥用处！   
    pipe函数原型：int pipe(int fd[2])   
    其中fd[0]表示读，fd[1]表示写  
    具体代码看pipe.c  

### 无名管道FIFO
    有名管道创建：mkfifo(管道名，管道打开的模式)  
    int mkfifo(const char *filename , mode_t mode )  
    其中管道打开模式有以下几种方式：
        1. O_RDONLY:读管道
        2. O_WRONLY:写管道
        3. O_RDWR:读写管道
        4. O_NONBLOCK:非阻塞
        5. O_CREAT:若文件不存在，则创建一个
        6. O_EXCL:测试文件是否存在
    函数返回值：
        成功：0
        失败：1
    代码查看fifo_read.c和fifo_write.c
    先运行read  再运行write

### 信号通信 
    Linux常见信号的含义
        SIGHUP:终端连接结束时发出                 终止
        SIGINT：键盘输入CTRL+C发出                终止
        SIGQUIT：ctrl+\                          终止
        SIGILL：                                 终止
        SIGFPE：                                 终止
        SIGKILL：                                终止
        SIGALRM：                                终止
        SIGSTOP：                                暂停进程
        SIGTSTP：键盘输入CTRL+Z                   停止进程
        SIGCHID：子进程改变时，父进程收到此信号     忽略
    
    信号的处理：
        发送信号：kill()和raise()
        捕捉信号：alarm()和pause()
        处理信号：signal和sigaction()

    相关代码：kill_raise.c
             alarm_pause.c
             signal.c 、sigaction.c
             sigset.c
    
    信号集函数组：常用函数
    看见函数名知道什么意思即可
        1. sigemptyset():将信号集树池花为空
        2. sigfillset(): 将信号集初始化为包含所有已定义的信号集。
        3. sigaddset():将指定信号加入到信号集中。
        4. sigdelset():将指定信号从信号集中删除。
        5. sigismember():查询指定信号是否在信号集中。


    注意根据实验结果深刻理解上面的Linux常见信号的含义
    

### 信号量编程--根据函数名知道啥异地即可！
    函数说明：
        创建信号量或获得系统已存在的信号量：semget()
        初始化信号量：semctl()函数的SETVAL操作
        pv操作：semop() -1为p 、+1为v
        删除信号量：semctl()函数的IPC_RMID操作
    
    相关代码阅读 sem_com.c 、 simple_fork.c

### 共享内存 
    函数说明：
        创建共享内存：shmget()
        内存地址映射：shmat()
        删除地址映射：shmdt()

    相关代码查看shmem.c

### 消息队列
    函数说明：
        创建或打开消息队列：msgget()
        添加消息：msgsnd(),加到队列尾
        读取消息：msgrcv()，从队列取出某一特定的消息
        控制消息队列：msgctl()，比如移除消息队列
    
    相关代码查看 msgsnd.c 、 msgrcv.c

## 实验内容--比较重要
### 有名管道通信实验--这是实验3的内容
    
[pipe_select.c源码](https://zengyimingming.github.io/2019/11/%E5%AE%9E%E9%AA%8C3/)

### 共享内存实验-消费者&生产者
[实验源码](https://zengyimingming.github.io/2019/11/%E5%AE%9E%E9%AA%8C1/)

### 多线程编程 



 

    









 










