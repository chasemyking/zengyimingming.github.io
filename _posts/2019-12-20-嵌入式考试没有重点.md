---
layout: post
title:  "嵌入式Linux考试没有重点"
imges: 
date:   2019-12-20 10:00:00 +0800
description: 赶紧背一波
tags: 嵌入式linux
---




[别看啦 没有重点](https://pan.baidu.com/s/17_I-bsA9UEAso0VKp-3TEg)

## 选择题一：
### 1. open函数打开的文件描述符fd要定位到文件尾的最后10个字符处,下列哪个代码正确。(D)

A. Iseek(fd, 10, SEEK SET)  
B. Iseek(fd, 10, SEEK END)  
C. Iseek(fd, 10, SEEK CUR)  
**D. Iseek(fd, -10, SEEK END)**  

### 2. 串口设备文件,用于其设置的结构体中,哪个是用于设置read函数的调用方式的(C)

A、c_lflag  
B、c_line  
**C、c_cc[NCC]**  
D、c_cflag  

### 3用fopen函数打开一个文件，用于把数据写在文件尾部，打开模式字符串为（ C    ）。

A、r+b  
B、wb  
**C、ab**  
D、rb  

### 4从标准控制台输入设备读取一个字符函数为（       B      ）。

A、fputc  
**B、fgetc**  
C、fputs  
D、fgets  

## 填空题一：
1. lockf函数对文件上的锁，是( **建议性**  )锁。

2. fcntl函数给文件上的读取锁，也称为( **共享**  )锁。

3. 常用格式化输出函数有( **vsprintf** )和( **sprintf**  )。

## 判断题一：
1. 代码 open( "/home/myfile",O_WRONLY | O_WRWR); 是否正确？  
**我的答案：×**

2. 用open函数打开的文件描述符，需用fclose函数关闭  
**我的答案：×**

3. 可以对文件的不同部分，分别建立读取锁和写入锁。  
**我的答案：√**

4. poll函数不能监听文件是否可写入的事件。   
**我的答案：×** 

5. 用fopen函数打开的可写文件，可用write函数写入数据。   
**我的答案：×**

## Linux多任务编程 
## 选择题二：
### 1. 进程结束前，需要清理IO缓冲，必须使用哪个函数（ B  ）。

A、_exit()  
**B、exit()**  
C、return  

### 2. 父进程等待子进程结束或接收到指定信号，非阻塞版本的函数是（ B       ）。

A、wait()  
**B、waitpid()**

### 3. 改变进程工作目录的函数是（    B   ）。

A、umusk  
**B、chdir**  
C、syslogopen  
D、fork  

## 填空题二：
1. 新进程要摆脱原进程和进程组的控制，需要调用( **setsid**  )函数。【只填函数名，无需参数】

2. 新建进程要成为守护进程，除了建立新的会话、改变当前目录，、重设文件权限掩码，还需要关闭从父进程继承下来的( **文件描述符**  )。

## 判断题二：
1. Linux中创建新进程的唯一方法是使用fork()函数。  
**我的答案：√** 

2. exec系列函数，用于在进程中启动一个程序。在执行之后，原调用进程的内容，除了PID，其它全部被新进程替换了。  
**我的答案：√** 

3. 僵尸进程会占用系统的内存资源，但不会占用进程号资源。  
**我的答案：×** 

4. 父进程使用wait或waitpid函数，可有效消除僵尸进程。  
**我的答案：√** 

5. 父进程忽略系统的SIGCHLD信号，也可避免产生僵尸进程。  
**我的答案：√**

## Linux进程间通信
## 选择题三：
### 1. 检查有名管道是否存在的函数是（         B       ）。

A、popen  
**B、access**    
C、fgets  
D、singnal  

### 2. 让进程暂停执行，可使用函数（       B          ）。

A、sleep  
**B、pause**

### 3. 进程要处理信号集，使用哪个函数（      B        ）。

A、signal  
**B、sigaction**    


### 4. 信号量的P操作是（  C    ）一个资源。

A、选择   
B、释放    
**C、占用**  
D、销毁    

### 5.创建共享内存的函数是（   B         ）。

A、shmat   
**B、shmget**  
C、shmdt  
D、shmctl    

## 填空题三：
1. 管道是基于(&emsp; **文件描述符**  &emsp;)的通信方式。创见无名管道的函数名是(&emsp; **pipe()**   &emsp;)。  

2. 创建有名管道的函数是（&emsp;     **mkfifo()**      &emsp;）。

3. 创建消息队列的函数是(&emsp; **msgget()**  &emsp;)  
   往消息队列添加消息的函数是(&emsp; **msgsnd()**  &emsp;)  
   从消息队列读取消息的函数是 <u> msgrcv() </u>  
## 判断题三：
1. Linux进程，只允许有一个闹钟时间，它会向进程发送SIGALRM信号。  
**我的答案：√**   

2. 信号量的P操作，是原子操作，如果没有资源可用，将阻塞进程。  
**我的答案：√**

---
## 考试内容绝大部分在学习通作业、教学案例、实验程序中、记函数名称，用法，分析实验结果。
# 对于书上的尽力而为叭,代码我就不粘贴了，主要是一些函数，能见名知意即可！

##### 基本文件操作
[！！可以先看看什么是文件描述符](http://c.biancheng.net/view/3066.html)

---

### 1. open() 、 close() 、read()、 write()  
函数详解:  

    1. int open(const char *pathname, int flag, int perms)    
    1）参数pathname:被打开的文件名可包含其路径   
    2）参数flag: 文件的打开方式（只写了3种）  
    O_RDONLY:只读方式打开文件  
    O_WRONLY:只写方式打开文件  
    O_RDWR:读写方式打开文件   
    3）参数 perms:  被打开文件的存取权限   
    可以使用宏定义S_I(R/W/X)(USR/GRP/OTH)
    R W X ：分别表示读写可执行权限   
    USR GRP OTH:分别表示文件所有者、文件所属组、其他用户  
    
    2. int close(int fd)  
    1）参数fd: 文件描述符  
    返回值：成功为0 、失败为-1

    3. ssize_t read(inf fd , void *buf , size_t count)  
    1）参数fd: 文件描述符   
    2）参数buf: 指定存储器读出数据的缓冲区  
    3）count: 指定读出的字节数  
    返回值：成功：读到的字节数   
            0：已到达文件尾   
            -1：出错  

    4. ssize_t write(inf fd , void *buf , size_t count)
    1）参数fd: 文件描述符   
    2）参数buf: 指定存储器写入数据的缓冲区  
    3）count: 指定读出的字节数  
    返回值：  
    成功：已写的字节数     
    -1：出错

    4. off_t lseek(int fd , off_t offset , int whenc__
    1）fd:文件描述符
    2）offset:偏移量，每次读写操作所需要移动端距离，单位是 __字节__
    3) whence:当前位置的基点
    返回值：  
    成功：文件的当前位移  
    -1：出错    

    #### 对应实例查看copy_file.c

---

### 2. 文件锁，涉及到两个函数fcntl()和lockf()  
    lockf()用于对文件施加建议性锁 ，这里不展开讲解 
    fcntl()可添加建议性锁、强制性锁、包括对文件的某一记录上锁，即记录锁。  

    1) int fcntl(int fd , int cmd , struct flock *lock)  
    参数fd:文件描述符  
    cmd:这个参数很多取值，具体看书47页  
    lock:设置记录锁的具体状态

    返回值：
        成功：0
        出错：-1
    
    #### 对应实例查看lock_set.c
    
### 3. 给文件上读取锁，写入锁 ，解锁

lock_set(fd,F_WRLCK)=>上写入锁，一个文件上了写入锁，另一个程序想再给这个文件上写入锁就不行了，就像是上厕所，一个坑只能同时蹲一个人，

lock_set(fd , F_RDLCK)=>上读取锁，一个文件上了读取锁，另一个终端程序也能同时对这个文件上读取锁，就像是看小说，大家一起看

lock_set(fd , F_UNLCK)=>给文件解锁

select()函数   
这里就提几个常用的  
FD_ZERO(fd_set *set)=>清除一个文件描述符集  
FD_SET(int fd , fd_set *set)=>将一个文件描述符加入文件描述符集中  
FD_ClR(int fd , fd_set *set)=>将一个文件描述符从文件描述符集中清除  
FD_ISSET(int fd , fd_set *set) => 判断一个文件描述符是否在文件描述符集中

##进程控制编程





